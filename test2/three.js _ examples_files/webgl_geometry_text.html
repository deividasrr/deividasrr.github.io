<!DOCTYPE html>
<!-- saved from url=(0054)https://threejs.org/examples/webgl_loader_collada.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>three.js webgl - collada</title>

<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
body {
	background:#777;
	padding:0;
	margin:0;
	font-weight: bold;
	overflow:hidden;
}

#info {
	position: absolute;
	top: 0px;
	width: 100%;
	color: #ffffff;
	padding: 5px;
	font-family:Monospace;
	font-size:13px;
	text-align:center;
}

a {
	color: #ffffff;
}
</style>
</head>
<body>

	<div id="container"></div>
	

	<script src="./three.js"></script>

	<script src="./ColladaLoader.js"></script>
	<script src="./OrbitControls.js"></script>

	<script>
	var container, stats;
	var camera, scene, renderer, controls;
	var objectMesh;
	var hasLoaded = false;

	init();
	animate();

	function init() {

		container = document.getElementById( 'container' );

		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
		camera.position.set( 7, 5, 7 );

		scene = new THREE.Scene();

				// collada



				var loader = new THREE.ColladaLoader();
				loader.options.convertUpAxis = true;
				loader.load( '../monster/monster.dae', function ( collada ) {

					objectMesh = collada.scene;

					objectMesh.scale.set( 0.0025, 0.0025, 0.0025 );
					objectMesh.position.set( - 2, 0.2, 0 );

					objectMesh.name = "monsta";

						// objectMesh.rotation.y = THREE.Math.randFloat( -0.25, 0.25 );
						// objectMesh.matrixAutoUpdate = false;
						// objectMesh.updateMatrix();

						objectMesh.rotateX(Math.PI / 90);

					scene.add( objectMesh );
					hasLoaded = true;


				} );

				//

				var gridHelper = new THREE.GridHelper( 10, 20 );
				scene.add( gridHelper );

				//

				var ambientLight = new THREE.AmbientLight( 0xcccccc );
				scene.add( ambientLight );

				var directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.set( 0, 10, -1 ).normalize();
				scene.add( directionalLight );

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//

				controls = new THREE.OrbitControls( camera, renderer.domElement );

				

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			var rotObjectMatrix;
			function rotateAroundObjectAxis(object, axis, radians) {
				rotObjectMatrix = new THREE.Matrix4();
				rotObjectMatrix.makeRotationAxis(axis.normalize(), radians);


				object.matrix.multiply(rotObjectMatrix);
				object.rotation.setFromRotationMatrix(object.matrix);
			}

			function animate() {

				console.log(objectMesh);

				requestAnimationFrame( animate );
				//object.material.color.setHex( 0x00ff00 );


				renderer.setClearColor( 0xf0f0f0, 1 ); // the default

				var yAxis = new THREE.Vector3(0,1,0);
				if(hasLoaded){





					objectMesh.scale.set( 0.0025, 0.0025, 0.0025 );
					//rotateAroundObjectAxis(objectMesh, yAxis, Math.PI / 180);
					//objectMesh.rotateX(Math.PI / 90);
					objectMesh.rotateY(Math.PI / 90);
									objectMesh.matrixAutoUpdate = false;
						objectMesh.updateMatrix();
				}

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

			</script>


		</body></html>